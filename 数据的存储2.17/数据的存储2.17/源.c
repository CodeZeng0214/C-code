#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//代码的进一步优化
//debug版本出错
//release没有出错，结果是系统自动优化了
/*int main()
{
	int i = 0;
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	printf("%p\n", &i);
		printf("%p\n", &arr[9]);
	for (i = 0; i <= 12; i++)
	{
		arr[i] = 0;
		printf("hehe\n");
	}
	return 0;
}*/

//数据的存储

//数据的类型
//整形家族
//浮点数家族
//字符型
//指针型
//空类型  void
//数组
//struct结构体类型
//enum枚举类型
//union联合体

//整形家族
/*int main()
{
	int a = -10;
	//数据在二进制内以二进制的形式存储，对整数来说二进制有三种表示形式
	//正整数：原码，反码，补码相同
	//负整数：原码，反码，补码要进行计算
	//按照数据的数值直接写出的二进制序列就是原码
	//原码的符号位不变，其他位按位取反，得到的就是反码
	//反码+1，得到的就是补码
	//在监视中，四个二进制位取一个十六进制位
	//内存中存的是补码
	return 0;
}*/
//1 - 1
//1 + (-1)
//00000000000000000000000000000001  1的原补反码
//11111111111111111111111111111110
//11111111111111111111111111111111  -1的补码
//10000000000000000000000000000001
//简单理解

//大端小端模式
/*
 int main()
 {
       int a = 0x11223344;
	   reurn 0;
 }
 //大端地址序：把数据的低位字节序的内容放在高地址处，低位字节序的内容放在低地址处
 //小端字节序刚好相反
 //注意不是大小顺序，是位顺序
*/

//设计一个小程序来判断当前机器字节序
/*int main()
{
	int a = 1;
	char* p = (char*)&a;//把a的首地址放在p中，考虑到类型
	printf("%d\n", *p);
	return 0;
}*/

//补充
//char与signed char是否等同取决于编译器，c语言没规定这个
//但规定int是signed
//short是signed

//%u是无符号类型
//整形提示补相同位

//考虑整形提升考虑有符号的char类型（在内存中存的）的范围
//-128到127，绕成了一个圈
//无符号数在打印时不用转换
//0在数组中代表\0

//死循环典例
/*unsigned char i = 0;
int main()
{
	for (i = 0; i <= 255; i++)
	{
		printf("hello");
	}
	return 0;
}*/


//浮点型

int main()
{
	int n = 9;
	float* pFloat = (float*)&n;
	printf("n的值为：%d\n", n);//
	printf("*pFloat的值为：%f\n", *pFloat);//以浮点数的视角去看
	*pFloat = 9.0;//以浮点数的视角去存储
	printf("num的值为：%d\n", n);//
	printf("*pFloat的值为：%f\n", *pFloat);//
	return 0;
}

//浮点数的存储与读取
//见课件！！！
